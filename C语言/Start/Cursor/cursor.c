/*
指针变量的大小取决于地址的大小
32位平台下地址是32个bit位（即4个字节）
64位平台下地址是64个bit位（即8个字节）

示例代码：
#include <stdio.h>

int main()
{
    printf("%d\n", sizeof(char *));
    printf("%d\n", sizeof(short *));
    printf("%d\n", sizeof(int *));
    printf("%d\n", sizeof(double *));
    return 0;
}

说明：
- 无论指针指向什么类型的变量，指针变量本身的大小都是固定的
- 在32位系统中，所有指针都是4个字节
- 在64位系统中，所有指针都是8个字节
- 这是因为指针存储的是内存地址，而地址的大小由系统架构决定

程序运行结果总结：
输出结果：
0x7ffce18534bc
10
0x7ffce18534bc
100

分析：
1. 初始状态：变量a=10，指针p指向a的地址0x7ffce18534bc
2. 修改后状态：通过*p=100修改了a的值，但指针p的地址值保持不变
3. 验证了指针的核心概念：
   - 指针存储的是内存地址（0x7ffce18534bc）
   - 通过解引用（*p）可以访问和修改该地址处的数据
   - 指针本身的值（地址）在修改数据时保持不变
   - %p占位符正确输出了十六进制格式的内存地址
*/


#include <stdio.h>
int main()
{
    int a = 10;
    int *p; // 这里的 * 号表示 p 是一个指针变量


    p = &a;
    printf("%p\n", p);
    printf("%d\n", *p);

    *p = 100; // 这里的 * 号表示解引用，即通过指针访问它指向的内存中的数据
    printf("%p\n", p);
    printf("%d\n", *p);
    
    return 0;
}
